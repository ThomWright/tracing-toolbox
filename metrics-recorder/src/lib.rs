//! [Metrics] recorder that outputs metric updates as [tracing] events.
//!
//! This recorder is mostly useful for debugging and testing purposes. It allows
//! outputting structured logs for the metrics produced by the application
//! (with tracing spans for context and other good stuff). The produced tracing events
//! can also be captured using the [`tracing-capture`] crate and tested.
//! The `tracing-capture` crate provides dedicated support to "parse" metrics
//! from the tracing events; see its docs for details.
//!
//! [Metrics]: https://docs.rs/metrics/
//! [tracing]: https://docs.rs/tracing/
//! [`tracing-capture`]: https://docs.rs/tracing-capture/
//!
//! # Event structure
//!
//! The events generated by the recorder are emitted on the `INFO` level with the target equal
//! to the name of this crate, i.e. `tracing_metrics_recorder`.
//! Events contain the following information:
//!
//! - Human-readable message like `counter test.latency = 0.025 seconds`
//! - `kind`: string representation of the metric kind (`counter`, `gauge` or `histogram`)
//! - `name`: name of the metric as specified in the corresponding macro
//! - `labels`: debug representation of the hash map of the labels associated with the metric,
//!   e.g. `{"location": "UK"}`. Optional.
//! - `prev_value`, `value`: previous and current value of the metric (unsigned integers
//!   for counters, floating-point values for metrics)
//! - `unit`: string representation of the metric unit (e.g., `seconds`). Optional.
//! - `description`: human-readable metric description specified using `metrics::describe_*`
//!   macros. Optional.
//!
//! # Examples
//!
//! ```
//! use metrics::Unit;
//! use tracing::Level;
//! use tracing_capture::{CaptureLayer, SharedStorage};
//! use tracing_subscriber::{filter, layer::SubscriberExt, Registry};
//! use tracing_metrics_recorder::TracingMetricsRecorder;
//! use std::time::Instant;
//! # use std::error::Error;
//!
//! // Install the metrics recorder and capturing metrics subscriber.
//! TracingMetricsRecorder::per_thread().install()?;
//! let storage = SharedStorage::default();
//! // Capture only metrics events.
//! let targets = filter::Targets::new()
//!     .with_target(TracingMetricsRecorder::TARGET, Level::INFO);
//! let layer = CaptureLayer::new(&storage).with_filter(targets);
//! let subscriber = Registry::default().with(layer);
//! tracing::subscriber::set_global_default(subscriber)?;
//!
//! // Execute code with metrics.
//! metrics::describe_histogram!("latency", Unit::Seconds, "Cycle latency");
//! for i in 0..5 {
//!     let start = Instant::now();
//!     metrics::counter!("count", 1);
//!     metrics::gauge!("oddity", (i % 2) as f64);
//!     metrics::histogram!("latency", start.elapsed());
//! }
//!
//! // Check that metrics are collected.
//! let storage = storage.lock();
//! let counter_value = storage.all_events().rev().find_map(|event| {
//!     let event = event.as_metric_update()?;
//!     if event.metric.name == "count" {
//!         return event.value.as_uint();
//!     }
//!     None
//! });
//! assert_eq!(counter_value, Some(5));
//!
//! let histogram_values = storage.all_events().filter_map(|event| {
//!     let event = event.as_metric_update()?;
//!     if event.metric.name == "latency" {
//!         assert_eq!(event.metric.unit, "seconds");
//!         assert_eq!(event.metric.description, "Cycle latency");
//!         return event.value.as_float();
//!     }
//!     None
//! });
//! let histogram_values: Vec<_> = histogram_values.collect();
//! assert_eq!(histogram_values.len(), 5);
//! println!("{histogram_values:?}");
//! # Ok::<_, Box<dyn Error>>(())
//! ```

// Documentation settings.
#![doc(html_root_url = "https://docs.rs/tracing-metrics-recorder/0.1.0")]
// Linter settings.
#![warn(missing_debug_implementations, missing_docs, bare_trait_objects)]
#![warn(clippy::all, clippy::pedantic)]
#![allow(clippy::must_use_candidate, clippy::module_name_repetitions)]

use metrics::{
    Counter, Gauge, Histogram, Key, KeyName, Recorder, SetRecorderError, SharedString, Unit,
};

use crate::router::GlobalRecorderGuard;
use std::sync::{Arc, RwLock};

mod helpers;
mod router;

pub use self::router::RecorderGuard;
use self::{
    helpers::{MetricData, MetricKind, MetricMaps, MetricMetadata, MetricMetadataMaps},
    router::RecorderRouter,
};

type MetricDataMaps = MetricMaps<Key, Arc<MetricData>>;

/// Metrics recorder that outputs metric updates as [tracing] events.
///
/// See [crate-level docs](index.html#event-structure) for details on the emitted events.
///
/// # How to install
///
/// ## In debugged applications
///
/// In the debugging use case, you may want to use [`Self::global()`]`.`[`install()`](Self::install()),
/// which will install a recorder that will collect metrics from all threads into a single place.
///
/// ```
/// # use tracing_metrics_recorder::TracingMetricsRecorder;
/// fn main() {
///     TracingMetricsRecorder::global().install().ok();
///     // Application code...
/// }
/// ```
///
/// ## In single-threaded tests
///
/// For use in tests, you may want to instantiate the recorder with [`Self::per_thread()`] instead:
///
/// ```
/// # use tracing_metrics_recorder::TracingMetricsRecorder;
/// #[test]
/// fn first_test() {
///     TracingMetricsRecorder::per_thread().install().ok();
///     // Test code...
/// }
///
/// #[test]
/// fn second_test() {
///     TracingMetricsRecorder::per_thread().install().ok();
///     // Test code...
/// }
/// ```
///
/// Otherwise, other tests running before and/or in parallel can interfere
/// with the gathered values. This, however, works only if tests and the tested code
/// do not spawn additional threads which report metrics. Interference *may* be acceptable
/// in certain conditions, e.g. if no counters are used and previous values of gauges / histograms
/// are not checked by the test code.
///
/// ## In multithreaded tests
///
/// If everything else fails, there is [`Self::install_exclusive()`]. It tracks metrics
/// from all threads, and uses a static mutex exclusively locked on each call to ensure
/// that there is no interference.
///
/// ```
/// # use tracing_metrics_recorder::TracingMetricsRecorder;
/// #[test]
/// fn first_test() {
///     let _guard = TracingMetricsRecorder::install_exclusive().unwrap();
///     // Test code...
/// }
///
/// #[test]
/// fn second_test() {
///     let _guard = TracingMetricsRecorder::install_exclusive().unwrap();
///     // Test code...
/// }
/// ```
///
/// Reporter installation will fail on subsequent calls in tests. As long as all tests install
/// the same recorder, this is fine; the installed recorder will provide tracing events for all
/// tests.
///
/// [tracing]: https://docs.rs/tracing/
///
/// # Examples
///
/// See the [crate-level docs](index.html#examples) for a complete example of usage.
#[must_use = "Created recorder should be `install()`ed"]
#[derive(Debug, Default)]
pub struct TracingMetricsRecorder {
    metadata: Arc<RwLock<MetricMetadataMaps>>,
    metrics: RwLock<MetricDataMaps>,
}

impl TracingMetricsRecorder {
    /// Target for the tracing events emitted by the recorder.
    pub const TARGET: &'static str = env!("CARGO_CRATE_NAME");

    /// # Errors
    ///
    /// FIXME
    pub fn install(self) -> Result<(), SetRecorderError> {
        metrics::set_boxed_recorder(Box::new(self))
    }

    /// # Errors
    ///
    /// FIXME
    pub fn set() -> Result<RecorderGuard, SetRecorderError> {
        RecorderRouter::install()?;
        Ok(RecorderRouter::set(Self::default()))
    }

    /// # Errors
    ///
    /// FIXME
    pub fn set_global() -> Result<GlobalRecorderGuard, SetRecorderError> {
        RecorderRouter::install()?;
        Ok(RecorderRouter::set_global(Self::default()))
    }

    fn get_or_insert_metric(&self, kind: MetricKind, key: &Key) -> Arc<MetricData> {
        let metrics = self.metrics.read().expect("metrics lock poisoned");
        if let Some(data) = metrics.get(kind, key) {
            return Arc::clone(data);
        }
        drop(metrics); // to prevent a deadlock on the next line

        let mut metrics = self.metrics.write().expect("metrics lock poisoned");
        if let Some(data) = metrics.get(kind, key) {
            Arc::clone(data)
        } else {
            let metadata = Arc::clone(&self.metadata);
            let metric = Arc::new(match kind {
                MetricKind::Counter => MetricData::new_counter(metadata, key.clone()),
                MetricKind::Gauge | MetricKind::Histogram => {
                    MetricData::new_gauge(metadata, key.clone())
                }
            });
            metrics.insert(kind, key.clone(), Arc::clone(&metric));
            metric
        }
    }
}

impl Recorder for TracingMetricsRecorder {
    fn describe_counter(&self, key: KeyName, unit: Option<Unit>, description: SharedString) {
        let mut metadata = self.metadata.write().expect("metadata lock poisoned");
        let key = key.as_str().to_owned();
        let metric_meta = MetricMetadata::new(unit, description);
        metadata.insert(MetricKind::Counter, key, metric_meta);
    }

    fn describe_gauge(&self, key: KeyName, unit: Option<Unit>, description: SharedString) {
        let mut metadata = self.metadata.write().expect("metadata lock poisoned");
        let key = key.as_str().to_owned();
        let metric_meta = MetricMetadata::new(unit, description);
        metadata.insert(MetricKind::Gauge, key, metric_meta);
    }

    fn describe_histogram(&self, key: KeyName, unit: Option<Unit>, description: SharedString) {
        let mut metadata = self.metadata.write().expect("metadata lock poisoned");
        let key = key.as_str().to_owned();
        let metric_meta = MetricMetadata::new(unit, description);
        metadata.insert(MetricKind::Histogram, key, metric_meta);
    }

    fn register_counter(&self, key: &Key) -> Counter {
        let counter = self.get_or_insert_metric(MetricKind::Counter, key);
        Counter::from_arc(counter)
    }

    fn register_gauge(&self, key: &Key) -> Gauge {
        let gauge = self.get_or_insert_metric(MetricKind::Gauge, key);
        Gauge::from_arc(gauge)
    }

    fn register_histogram(&self, key: &Key) -> Histogram {
        let histogram = self.get_or_insert_metric(MetricKind::Histogram, key);
        Histogram::from_arc(histogram)
    }
}

#[cfg(doctest)]
doc_comment::doctest!("../README.md");
