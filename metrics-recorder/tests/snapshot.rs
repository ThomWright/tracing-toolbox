//! Snapshot-testing for the tracing events generated by `TracingMetricsRecorder`.
//! This is a separate test to ensure that all events are captured.

use metrics::Unit;

use std::{sync::mpsc, time::Duration};

use tracing_metrics_recorder::TracingMetricsRecorder;
use tracing_tunnel::{TracingEvent, TracingEventSender};

fn generate_metrics() {
    metrics::describe_histogram!(
        "greeting.latency",
        Unit::Seconds,
        "time spent on a greeting"
    );

    tracing::info_span!("greeting").in_scope(|| {
        for i in 0..5 {
            let _entered = tracing::info_span!("iteration", i).entered();
            metrics::counter!("greeting.count", 1);
            metrics::gauge!("greeting.oddity", (i % 2) as f64);
            metrics::histogram!(
                "greeting.latency",
                Duration::from_millis(10 * (i + 1)),
                "oddity" => (i % 2).to_string()
            );
        }
    });
}

fn collect_metric_events() -> Vec<TracingEvent> {
    let (events_sx, events_rx) = mpsc::sync_channel(100);
    let sender = TracingEventSender::new(move |event| {
        events_sx.send(event).unwrap();
    });

    tracing::subscriber::with_default(sender, generate_metrics);
    events_rx.iter().collect()
}

#[test]
fn metrics_event_snapshot() {
    let _guard = TracingMetricsRecorder::set().unwrap();
    let mut events = collect_metric_events();
    TracingEvent::normalize(&mut events);

    insta::assert_yaml_snapshot!("metrics-events", events);
}
